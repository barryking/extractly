/**
 * Standard PDF character encodings.
 *
 * Each encoding maps byte values (0-255) to Unicode code points.
 * A value of 0 means the byte is unmapped.
 */

/** WinAnsiEncoding - the most common PDF encoding (Windows Latin-1 superset) */
export const WinAnsiEncoding: readonly number[] = (() => {
  const enc = new Array<number>(256).fill(0);

  // 0x00-0x1F: control characters (mostly unmapped)
  // 0x20-0x7E: ASCII
  for (let i = 0x20; i <= 0x7e; i++) enc[i] = i;

  // Windows-1252 specific mappings for 0x80-0x9F
  enc[0x80] = 0x20ac; // Euro sign
  enc[0x82] = 0x201a; // Single Low-9 Quotation Mark
  enc[0x83] = 0x0192; // Latin Small Letter F With Hook
  enc[0x84] = 0x201e; // Double Low-9 Quotation Mark
  enc[0x85] = 0x2026; // Horizontal Ellipsis
  enc[0x86] = 0x2020; // Dagger
  enc[0x87] = 0x2021; // Double Dagger
  enc[0x88] = 0x02c6; // Modifier Letter Circumflex Accent
  enc[0x89] = 0x2030; // Per Mille Sign
  enc[0x8a] = 0x0160; // Latin Capital Letter S With Caron
  enc[0x8b] = 0x2039; // Single Left-Pointing Angle Quotation Mark
  enc[0x8c] = 0x0152; // Latin Capital Ligature OE
  enc[0x8e] = 0x017d; // Latin Capital Letter Z With Caron
  enc[0x91] = 0x2018; // Left Single Quotation Mark
  enc[0x92] = 0x2019; // Right Single Quotation Mark
  enc[0x93] = 0x201c; // Left Double Quotation Mark
  enc[0x94] = 0x201d; // Right Double Quotation Mark
  enc[0x95] = 0x2022; // Bullet
  enc[0x96] = 0x2013; // En Dash
  enc[0x97] = 0x2014; // Em Dash
  enc[0x98] = 0x02dc; // Small Tilde
  enc[0x99] = 0x2122; // Trade Mark Sign
  enc[0x9a] = 0x0161; // Latin Small Letter S With Caron
  enc[0x9b] = 0x203a; // Single Right-Pointing Angle Quotation Mark
  enc[0x9c] = 0x0153; // Latin Small Ligature oe
  enc[0x9e] = 0x017e; // Latin Small Letter Z With Caron
  enc[0x9f] = 0x0178; // Latin Capital Letter Y With Diaeresis

  // 0xA0-0xFF: Latin-1 Supplement
  for (let i = 0xa0; i <= 0xff; i++) enc[i] = i;

  // Space and common control chars
  enc[0x09] = 0x09; // tab
  enc[0x0a] = 0x0a; // LF
  enc[0x0d] = 0x0d; // CR

  return enc;
})();

/** MacRomanEncoding */
export const MacRomanEncoding: readonly number[] = (() => {
  const enc = new Array<number>(256).fill(0);

  // ASCII range
  for (let i = 0x20; i <= 0x7e; i++) enc[i] = i;
  enc[0x09] = 0x09;
  enc[0x0a] = 0x0a;
  enc[0x0d] = 0x0d;

  // Mac Roman high byte mappings
  const macHighBytes: Record<number, number> = {
    0x80: 0x00c4, 0x81: 0x00c5, 0x82: 0x00c7, 0x83: 0x00c9,
    0x84: 0x00d1, 0x85: 0x00d6, 0x86: 0x00dc, 0x87: 0x00e1,
    0x88: 0x00e0, 0x89: 0x00e2, 0x8a: 0x00e4, 0x8b: 0x00e3,
    0x8c: 0x00e5, 0x8d: 0x00e7, 0x8e: 0x00e9, 0x8f: 0x00e8,
    0x90: 0x00ea, 0x91: 0x00eb, 0x92: 0x00ed, 0x93: 0x00ec,
    0x94: 0x00ee, 0x95: 0x00ef, 0x96: 0x00f1, 0x97: 0x00f3,
    0x98: 0x00f2, 0x99: 0x00f4, 0x9a: 0x00f6, 0x9b: 0x00f5,
    0x9c: 0x00fa, 0x9d: 0x00f9, 0x9e: 0x00fb, 0x9f: 0x00fc,
    0xa0: 0x2020, 0xa1: 0x00b0, 0xa2: 0x00a2, 0xa3: 0x00a3,
    0xa4: 0x00a7, 0xa5: 0x2022, 0xa6: 0x00b6, 0xa7: 0x00df,
    0xa8: 0x00ae, 0xa9: 0x00a9, 0xaa: 0x2122, 0xab: 0x00b4,
    0xac: 0x00a8, 0xad: 0x2260, 0xae: 0x00c6, 0xaf: 0x00d8,
    0xb0: 0x221e, 0xb1: 0x00b1, 0xb2: 0x2264, 0xb3: 0x2265,
    0xb4: 0x00a5, 0xb5: 0x00b5, 0xb6: 0x2202, 0xb7: 0x2211,
    0xb8: 0x220f, 0xb9: 0x03c0, 0xba: 0x222b, 0xbb: 0x00aa,
    0xbc: 0x00ba, 0xbd: 0x2126, 0xbe: 0x00e6, 0xbf: 0x00f8,
    0xc0: 0x00bf, 0xc1: 0x00a1, 0xc2: 0x00ac, 0xc3: 0x221a,
    0xc4: 0x0192, 0xc5: 0x2248, 0xc6: 0x2206, 0xc7: 0x00ab,
    0xc8: 0x00bb, 0xc9: 0x2026, 0xca: 0x00a0, 0xcb: 0x00c0,
    0xcc: 0x00c3, 0xcd: 0x00d5, 0xce: 0x0152, 0xcf: 0x0153,
    0xd0: 0x2013, 0xd1: 0x2014, 0xd2: 0x201c, 0xd3: 0x201d,
    0xd4: 0x2018, 0xd5: 0x2019, 0xd6: 0x00f7, 0xd7: 0x25ca,
    0xd8: 0x00ff, 0xd9: 0x0178, 0xda: 0x2044, 0xdb: 0x20ac,
    0xdc: 0x2039, 0xdd: 0x203a, 0xde: 0xfb01, 0xdf: 0xfb02,
    0xe0: 0x2021, 0xe1: 0x00b7, 0xe2: 0x201a, 0xe3: 0x201e,
    0xe4: 0x2030, 0xe5: 0x00c2, 0xe6: 0x00ca, 0xe7: 0x00c1,
    0xe8: 0x00cb, 0xe9: 0x00c8, 0xea: 0x00cd, 0xeb: 0x00ce,
    0xec: 0x00cf, 0xed: 0x00cc, 0xee: 0x00d3, 0xef: 0x00d4,
    0xf0: 0xf8ff, 0xf1: 0x00d2, 0xf2: 0x00da, 0xf3: 0x00db,
    0xf4: 0x00d9, 0xf5: 0x0131, 0xf6: 0x02c6, 0xf7: 0x02dc,
    0xf8: 0x00af, 0xf9: 0x02d8, 0xfa: 0x02d9, 0xfb: 0x02da,
    0xfc: 0x00b8, 0xfd: 0x02dd, 0xfe: 0x02db, 0xff: 0x02c7,
  };

  for (const [byte, unicode] of Object.entries(macHighBytes)) {
    enc[Number(byte)] = unicode;
  }

  return enc;
})();

/** StandardEncoding (Adobe Standard) */
export const StandardEncoding: readonly number[] = (() => {
  const enc = new Array<number>(256).fill(0);

  // ASCII range
  for (let i = 0x20; i <= 0x7e; i++) enc[i] = i;

  // Standard encoding specific overrides
  enc[0x27] = 0x2019; // quoteright
  enc[0x60] = 0x2018; // quoteleft

  // High byte mappings specific to StandardEncoding
  const stdHighBytes: Record<number, number> = {
    0xa1: 0x00a1, 0xa2: 0x00a2, 0xa3: 0x00a3, 0xa4: 0x2044,
    0xa5: 0x00a5, 0xa6: 0x0192, 0xa7: 0x00a7, 0xa8: 0x00a4,
    0xa9: 0x0027, 0xaa: 0x201c, 0xab: 0x00ab, 0xac: 0x2039,
    0xad: 0x203a, 0xae: 0xfb01, 0xaf: 0xfb02,
    0xb1: 0x2013, 0xb2: 0x2020, 0xb3: 0x2021, 0xb4: 0x00b7,
    0xb6: 0x00b6, 0xb7: 0x2022, 0xb8: 0x201a, 0xb9: 0x201e,
    0xba: 0x201d, 0xbb: 0x00bb, 0xbc: 0x2026, 0xbd: 0x2030,
    0xc1: 0x0060, 0xc2: 0x00b4, 0xc3: 0x02c6, 0xc4: 0x02dc,
    0xc5: 0x00af, 0xc6: 0x02d8, 0xc7: 0x02d9, 0xc8: 0x00a8,
    0xca: 0x02da, 0xcb: 0x00b8, 0xcc: 0x02dd, 0xcd: 0x02db,
    0xce: 0x02c7, 0xcf: 0x2014,
    0xe1: 0x00c6, 0xe3: 0x00aa, 0xe8: 0x0141, 0xe9: 0x00d8,
    0xea: 0x0152, 0xeb: 0x00ba,
    0xf1: 0x00e6, 0xf5: 0x0131, 0xf8: 0x0142, 0xf9: 0x00f8,
    0xfa: 0x0153, 0xfb: 0x00df,
  };

  for (const [byte, unicode] of Object.entries(stdHighBytes)) {
    enc[Number(byte)] = unicode;
  }

  return enc;
})();

/** PDFDocEncoding - used for text strings in PDF metadata */
export const PDFDocEncoding: readonly number[] = (() => {
  const enc = new Array<number>(256).fill(0);

  // Most of it matches Latin-1
  for (let i = 0; i <= 0xff; i++) enc[i] = i;

  // Override the 0x80-0x9F range (like WinAnsi but with some differences)
  enc[0x80] = 0x2022; // Bullet
  enc[0x81] = 0x2020; // Dagger
  enc[0x82] = 0x2021; // Double Dagger
  enc[0x83] = 0x2026; // Horizontal Ellipsis
  enc[0x84] = 0x2014; // Em Dash
  enc[0x85] = 0x2013; // En Dash
  enc[0x86] = 0x0192; // Latin Small Letter F With Hook
  enc[0x87] = 0x2044; // Fraction Slash
  enc[0x88] = 0x2039; // Single Left-Pointing Angle Quotation Mark
  enc[0x89] = 0x203a; // Single Right-Pointing Angle Quotation Mark
  enc[0x8a] = 0x2212; // Minus Sign
  enc[0x8b] = 0x2030; // Per Mille Sign
  enc[0x8c] = 0x201e; // Double Low-9 Quotation Mark
  enc[0x8d] = 0x201c; // Left Double Quotation Mark
  enc[0x8e] = 0x201d; // Right Double Quotation Mark
  enc[0x8f] = 0x2018; // Left Single Quotation Mark
  enc[0x90] = 0x2019; // Right Single Quotation Mark
  enc[0x91] = 0x201a; // Single Low-9 Quotation Mark
  enc[0x92] = 0x2122; // Trade Mark Sign
  enc[0x93] = 0xfb01; // Latin Small Ligature fi
  enc[0x94] = 0xfb02; // Latin Small Ligature fl
  enc[0x95] = 0x0141; // Latin Capital Letter L With Stroke
  enc[0x96] = 0x0152; // Latin Capital Ligature OE
  enc[0x97] = 0x0160; // Latin Capital Letter S With Caron
  enc[0x98] = 0x0178; // Latin Capital Letter Y With Diaeresis
  enc[0x99] = 0x017d; // Latin Capital Letter Z With Caron
  enc[0x9a] = 0x0131; // Latin Small Letter Dotless I
  enc[0x9b] = 0x0142; // Latin Small Letter L With Stroke
  enc[0x9c] = 0x0153; // Latin Small Ligature oe
  enc[0x9d] = 0x0161; // Latin Small Letter S With Caron
  enc[0x9e] = 0x017e; // Latin Small Letter Z With Caron
  enc[0xa0] = 0x20ac; // Euro Sign
  enc[0xad] = 0x00ad; // Soft Hyphen

  return enc;
})();

/** Get encoding table by name */
export function getEncodingByName(name: string): readonly number[] | null {
  switch (name) {
    case 'WinAnsiEncoding': return WinAnsiEncoding;
    case 'MacRomanEncoding': return MacRomanEncoding;
    case 'StandardEncoding': return StandardEncoding;
    case 'PDFDocEncoding': return PDFDocEncoding;
    default: return null;
  }
}

/** Decode a PDF text string (from PdfString bytes) to a JS string */
export function decodePdfString(bytes: Uint8Array): string {
  if (bytes.length === 0) return '';

  // Check for UTF-16 BOM (big-endian)
  if (bytes.length >= 2 && bytes[0] === 0xfe && bytes[1] === 0xff) {
    let result = '';
    for (let i = 2; i < bytes.length - 1; i += 2) {
      result += String.fromCharCode((bytes[i] << 8) | bytes[i + 1]);
    }
    return result;
  }

  // Check for UTF-8 BOM
  if (bytes.length >= 3 && bytes[0] === 0xef && bytes[1] === 0xbb && bytes[2] === 0xbf) {
    return new TextDecoder('utf-8').decode(bytes.subarray(3));
  }

  // PDFDocEncoding
  let result = '';
  for (let i = 0; i < bytes.length; i++) {
    const cp = PDFDocEncoding[bytes[i]];
    result += cp ? String.fromCodePoint(cp) : '';
  }
  return result;
}
